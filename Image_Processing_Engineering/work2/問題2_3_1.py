# -*- coding: utf-8 -*-
"""問題2-3-1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OwZO9eY3hMiF-v-SEBzxZ-4SCiz3TaxX
"""

# ドライブのマウント
from google.colab import drive
drive.mount('/content/drive')

# モジュールのインポート
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 共通のディレクトリパス
common_path = '/content/drive/MyDrive/img2025/image/'

# 画像を読み込む
filename = 'a2-5_gray_image.png'
gray_img = cv2.imread(common_path + filename, cv2.IMREAD_GRAYSCALE)

# 画像を正方形（512x512）にトリミングする処理
# 画像の中心から指定サイズを切り出す
h, w = gray_img.shape
crop_size = 512

# 画像サイズがトリミングサイズより小さい場合の例外処理（念のため）
if h < crop_size or w < crop_size:
    print(f"画像サイズが小さいため、トリミングサイズを調整します: {min(h, w)}")
    crop_size = min(h, w)

center_y, center_x = h // 2, w // 2
start_x = center_x - crop_size // 2
start_y = center_y - crop_size // 2
cropped_img = gray_img[start_y:start_y+crop_size, start_x:start_x+crop_size]

# 2次元高速フーリエ変換（2D-FFT）
fourier = np.fft.fft2(cropped_img)

# ゼロ周波数成分（直流成分）を画像の中心にシフトする
fshift = np.fft.fftshift(fourier)

# 振幅スペクトルを計算する
amp_spectrum = np.abs(fshift)

# 対数スケールに変換（見やすくするため +1 して log をとる）
log_amp_spectrum = 20 * np.log10(amp_spectrum + 1)

# 実行結果の表示
plt.figure(figsize=(10, 5))

# トリミング後の元画像
plt.subplot(1, 2, 1)
plt.title('Cropped Image (512x512)')
plt.imshow(cropped_img, cmap='gray', vmin=0, vmax=255)
plt.axis('off')

# 振幅スペクトル（対数スケール・中心化済み）
plt.subplot(1, 2, 2)
plt.title('Magnitude Spectrum (Log Scale)')
plt.imshow(log_amp_spectrum, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()

# ==========================================
# 課題4: 2種類以上の周波数フィルタの適用と考察
# ==========================================

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import drive

# 1. ドライブのマウントと画像の読み込み
# drive.mount('/content/drive') # すでにマウント済みの場合はコメントアウトでOK

common_path = '/content/drive/MyDrive/img2025/image/'
filename = 'a2-5_gray_image.png'

# 画像読み込み
gray_img = cv2.imread(common_path + filename, cv2.IMREAD_GRAYSCALE)

# 2. 画像の正方形トリミング（課題3の処理を継承）
# 画像の中心から512x512を切り出す
h, w = gray_img.shape
crop_size = 512

# 画像サイズが小さい場合のガード処理
target_size = min(h, w, crop_size)

center_y, center_x = h // 2, w // 2
start_y = center_y - target_size // 2
start_x = center_x - target_size // 2
img = gray_img[start_y:start_y+target_size, start_x:start_x+target_size]

# 3. FFTの実行とシフト
f = np.fft.fft2(img)
fshift = np.fft.fftshift(f) # 直流成分を中心に移動

# ---------------------------------------------------------
# フィルタ生成関数の定義
# ---------------------------------------------------------

def create_ideal_lowpass(shape, cutoff):
    """
    理想ローパスフィルタ: 指定した半径(cutoff)の内側を通し、外側をカット
    """
    rows, cols = shape
    crow, ccol = rows // 2, cols // 2

    y, x = np.ogrid[:rows, :cols]
    # 中心からの距離の二乗を計算
    dist_sq = (x - ccol)**2 + (y - crow)**2

    mask = np.zeros(shape)
    # 距離がcutoff以内なら1
    mask[dist_sq <= cutoff**2] = 1
    return mask

def create_gaussian_highpass(shape, cutoff):
    """
    ガウシアンハイパスフィルタ: 低周波を滑らかに減衰させ、高周波を通す
    H(u,v) = 1 - exp(-D^2 / 2D0^2)
    """
    rows, cols = shape
    crow, ccol = rows // 2, cols // 2

    y, x = np.ogrid[:rows, :cols]
    dist_sq = (x - ccol)**2 + (y - crow)**2

    # ガウシアンローパスの逆（1から引く）
    mask = 1 - np.exp(-dist_sq / (2 * (cutoff**2)))
    return mask

# ---------------------------------------------------------
# フィルタの適用
# ---------------------------------------------------------

# パラメータ設定（遮断周波数）
D0_low = 30   # ローパス用
D0_high = 30  # ハイパス用

# マスクの作成
mask_ilpf = create_ideal_lowpass(img.shape, D0_low)
mask_ghpf = create_gaussian_highpass(img.shape, D0_high)

# 周波数領域でのフィルタリング（要素ごとの掛け算）
fshift_ilpf = fshift * mask_ilpf
fshift_ghpf = fshift * mask_ghpf

# 逆FFT処理（シフトを戻して逆変換し、実部を取る）
img_ilpf = np.fft.ifft2(np.fft.ifftshift(fshift_ilpf)).real
img_ghpf = np.fft.ifft2(np.fft.ifftshift(fshift_ghpf)).real

# ---------------------------------------------------------
# 結果の可視化
# ---------------------------------------------------------
plt.figure(figsize=(12, 8))

# --- 上段: 理想ローパスフィルタ ---
plt.subplot(2, 3, 1)
plt.title('Original Image')
plt.imshow(img, cmap='gray', vmin=0, vmax=255)
plt.axis('off')

plt.subplot(2, 3, 2)
plt.title(f'Ideal Low Pass Filter Mask\n(Cutoff={D0_low})')
plt.imshow(mask_ilpf, cmap='gray', vmin=0, vmax=1)
plt.axis('off')

plt.subplot(2, 3, 3)
plt.title('Filtered Result (ILPF)')
plt.imshow(img_ilpf, cmap='gray') # 値の範囲は自動調整
plt.axis('off')

# --- 下段: ガウシアンハイパスフィルタ ---
plt.subplot(2, 3, 4)
plt.title('Original Image')
plt.imshow(img, cmap='gray', vmin=0, vmax=255)
plt.axis('off')

plt.subplot(2, 3, 5)
plt.title(f'Gaussian High Pass Filter Mask\n(Cutoff={D0_high})')
plt.imshow(mask_ghpf, cmap='gray', vmin=0, vmax=1)
plt.axis('off')

plt.subplot(2, 3, 6)
plt.title('Filtered Result (GHPF)')
plt.imshow(np.abs(img_ghpf), cmap='gray') # 振幅を表示
plt.axis('off')

plt.tight_layout()
plt.show()