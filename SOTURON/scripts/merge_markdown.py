#!/usr/bin/env python3
"""Merge multiple Markdown files into one (cross-platform).
Features:
- preserve first-file YAML front-matter
- strip subsequent front-matter
- optional TOC generation
- inserts provenance headers for each source file
"""
from pathlib import Path
import argparse
import re
import sys

HEADING_RE = re.compile(r'^(#{1,6})\s+(.*)')
YAML_BOUNDARY = re.compile(r'^---\s*$')


def read_md(path: Path):
    lines = path.read_text(encoding='utf-8').splitlines()
    return lines


def strip_leading_yaml(lines):
    if lines and YAML_BOUNDARY.match(lines[0]):
        for i in range(1, len(lines)):
            if YAML_BOUNDARY.match(lines[i]):
                return lines[i+1:]
    return lines


def extract_headings(lines):
    out = []
    for ln in lines:
        m = HEADING_RE.match(ln)
        if m:
            out.append((len(m.group(1)), m.group(2).strip()))
    return out


def gh_anchor(text: str) -> str:
    a = re.sub(r"[^a-z0-9\s-]", "", text.lower())
    a = re.sub(r"\s+", "-", a)
    a = re.sub(r"-+", "-", a)
    return a.strip('-')


def merge(files, output: Path, add_toc: bool, force: bool):
    if output.exists() and not force:
        print(f"Error: {output} exists (use --force)")
        sys.exit(2)
    merged = []
    all_headings = []
    first = True
    for p in files:
        p = Path(p)
        if not p.exists():
            print(f"warning: skip missing {p}")
            continue
        lines = read_md(p)
        if lines and YAML_BOUNDARY.match(lines[0]):
            if first:
                # keep
                pass
            else:
                lines = strip_leading_yaml(lines)
        # remove H1 that is identical to filename
        if lines and HEADING_RE.match(lines[0]):
            lvl, txt = HEADING_RE.match(lines[0]).groups()
            name = p.stem
            if txt.strip() == name:
                lines = lines[1:]
        hs = extract_headings(lines)
        all_headings += [(p.name, h[0], h[1]) for h in hs]
        if first:
            merged += lines
            first = False
        else:
            merged += ['']
            merged += [f'<!-- source: {p} | merged-at: -->']
            merged += [f'## Source: {p.name}']
            merged += ['']
            merged += lines
    # build TOC
    if add_toc:
        toc = ['<!-- TOC: autogenerated -->']
        for src, lvl, txt in all_headings:
            indent = '  ' * max(0, lvl-2)
            toc.append(
                f"{indent}- [{txt}](#{gh_anchor(txt)})  <!-- from: {src} -->")
        toc.append('')
        # insert after YAML if present
        if merged and YAML_BOUNDARY.match(merged[0]):
            end = 0
            for i in range(1, len(merged)):
                if YAML_BOUNDARY.match(merged[i]):
                    end = i
                    break
            if end:
                out = merged[:end+1] + [''] + toc + merged[end+1:]
            else:
                out = toc + merged
        else:
            out = toc + merged
    else:
        out = merged
    output.write_text('\n'.join(out), encoding='utf-8')
    print(f"Merged {len(files)} -> {output}")


def main():
    p = argparse.ArgumentParser(description=__doc__)
    p.add_argument('inputs', nargs='*',
                   help='input files (ordered). If empty, glob "資料/*_formatted.md" is used')
    p.add_argument('-o', '--output', default='merged_markdown.md')
    p.add_argument('--toc', action='store_true')
    p.add_argument('-f', '--force', action='store_true')
    args = p.parse_args()
    if not args.inputs:
        from glob import glob
        args.inputs = sorted(glob('資料/*_formatted.md'))
    merge(args.inputs, Path(args.output), args.toc, args.force)


if __name__ == '__main__':
    main()
