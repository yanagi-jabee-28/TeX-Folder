<#
.SYNOPSIS
  Merge multiple Markdown files into a single Markdown file (Windows PowerShell).
.DESCRIPTION
  - Preserves the first file's YAML front-matter (if present) and strips subsequent front-matter blocks.
  - Optionally builds a lightweight TOC from headings found in the inputs.
  - Inserts a source-comment / filename heading before each file's content to keep provenance.
  - Avoids overwriting the output unless -Force is provided.
.PARAMETER InputFiles
  Explicit list of input files (ordered). If omitted, -Glob is used to discover files.
.PARAMETER Glob
  Glob pattern (relative to repository root) used when InputFiles not provided. Default: "資料/*_formatted.md".
.PARAMETER Output
  Output merged markdown path. Default: ./merged_markdown.md
.PARAMETER AddTOC
  Add a generated table of contents at the top.
.PARAMETER Force
  Overwrite existing output file.
.EXAMPLE
  # merge the project's formatted literature into one file
  .\merge_markdown.ps1 -Glob '資料/*_formatted.md' -Output merged_materials.md -AddTOC -Force
#>
[CmdletBinding()]
param(
	[Parameter(Position = 0, ValueFromPipeline = $true)]
	[string[]] $InputFiles,

	[string] $Glob = '資料/*_formatted.md',
	[string] $Output = 'merged_markdown.md',
	[switch] $AddTOC,
	[switch] $Force
)

function Get-HeadingsFromText {
	param([string[]] $lines)
	$h = @()
	foreach ($l in $lines) {
		if ($l -match '^(#{1,6})\s+(.*)') {
			$level = $matches[1].Length
			$text = $matches[2].Trim()
			$h += [pscustomobject]@{level = $level; text = $text }
		}
	}
	return $h
}
# PSScriptAnalyzer:IgnoreRule PSUseApprovedVerbs
# Reason: function name uses an *approved* verb form `ConvertTo-` to satisfy the rule.
function ConvertTo-GitHubAnchor {
param([string] $text)
$a = $text.ToLower() -replace "[^a-z0-9\s-]", "" -replace '\s+', '-' -replace '-+', '-'
return $a.Trim('-')
}

# discover files if not provided
if (-not $InputFiles -or $InputFiles.Count -eq 0) {
	$InputFiles = Get-ChildItem -Path $Glob -File -ErrorAction SilentlyContinue | Sort-Object Name | ForEach-Object { $_.FullName }
}

if (-not $InputFiles -or $InputFiles.Count -eq 0) {
	Write-Error "No input files found (check -InputFiles or -Glob)."
	exit 2
}

# normalize paths
$InputFiles = $InputFiles | ForEach-Object { Resolve-Path -LiteralPath $_ }.Where({ $_ -ne $null })

if ((Test-Path $Output) -and -not $Force) {
	Write-Error "Output file '$Output' already exists. Use -Force to overwrite."
	exit 3
}

$merged = @()
$globalHeadings = @()
$first = $true

foreach ($f in $InputFiles) {
	if (-not (Test-Path $f)) { Write-Warning "skip missing: $f"; continue }
	$lines = Get-Content -LiteralPath $f -ErrorAction Stop

	# detect and strip YAML front-matter for non-first files
	if ($lines.Count -gt 0 -and $lines[0] -match '^---\s*$') {
		$end = ($lines | Select-Object -Skip 1 | Select-String -Pattern '^---\s*$' -SimpleMatch -List).LineNumber
		if ($end) {
			if ($first) {
				# keep YAML for first file
			}
			else {
				$lines = $lines[($end)..($lines.Count - 1)]
			}
		}
	}

	# remove leading top-level title if it's identical to filename (avoid duplicate H1s)
	if ($lines.Count -gt 0 -and $lines[0] -match '^#\s+' ) {
		$title = ($lines[0] -replace '^#\s+', '').Trim()
		if ($title -eq [IO.Path]::GetFileNameWithoutExtension($f)) {
			$lines = $lines[1..($lines.Count - 1)]
		}
	}

	# collect headings for TOC
	$hs = Get-HeadingsFromText -lines $lines
	foreach ($hh in $hs) { $globalHeadings += [pscustomobject]@{source = [IO.Path]::GetFileName($f); level = $hh.level; text = $hh.text } }

	# provenance header
	$prov = "<!-- source: $([IO.Path]::GetRelativePath((Get-Location).Path, $f)) | merged-at: $(Get-Date -Format s) -->"
	$provTitle = "## Source: $([IO.Path]::GetFileName($f))"

	if ($first) {
		$merged += $lines
		$first = $false
	}
 else {
		$merged += ''
		$merged += $prov
		$merged += $provTitle
		$merged += ''
		$merged += $lines
	}
}

# build TOC
$tocBlock = @()
if ($AddTOC) {
	$tocBlock += "<!-- TOC: autogenerated -->"
	foreach ($entry in $globalHeadings) {
		$indent = '  ' * ([math]::Max(0, $entry.level - 2))
		$anchor = ConvertTo-GitHubAnchor $entry.text
		$tocBlock += "${indent}- [$($entry.text)](#${anchor})  <!-- from: $($entry.source) -->"
	}
	$tocBlock += ''
}

# if there's a YAML front-matter at top of merged (kept from first file), insert TOC after it; otherwise at top
$outputLines = @()
if ($AddTOC -and $merged.Count -gt 0 -and $merged[0] -match '^---\s*$') {
	# find end of YAML
	$endIdx = ($merged | Select-Object -Skip 1 | Select-String -Pattern '^---\s*$' -SimpleMatch -List).LineNumber
	if ($endIdx) { $endIdx = $endIdx } else { $endIdx = 0 }
	if ($endIdx -gt 0) {
		$outputLines += $merged[0..$endIdx]
		$outputLines += ''
		$outputLines += $tocBlock
		$outputLines += $merged[($endIdx + 1)..($merged.Count - 1)]
	}
 else {
		$outputLines += $tocBlock
		$outputLines += $merged
	}
}
elseif ($AddTOC) {
	$outputLines += $tocBlock
	$outputLines += $merged
}
else {
	$outputLines = $merged
}

# write
$outputDir = [IO.Path]::GetDirectoryName((Resolve-Path -LiteralPath $Output).Path)
if (-not $outputDir) { $outputDir = Get-Location }
$outputLines | Out-File -FilePath $Output -Encoding UTF8 -Force

Write-Output "Merged $($InputFiles.Count) files -> $Output"
exit 0
